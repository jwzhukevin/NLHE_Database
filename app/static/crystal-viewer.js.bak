/**
 * crystal-viewer.js
 * 使用Three.js实现晶体结构的3D可视化
 * 这个文件提供了晶体结构的交互式3D可视化功能
 */

// 全局变量声明
let scene, camera, renderer, controls; // 声明Three.js的基本组件：场景、相机、渲染器和控制器
let crystalGroup; // 用于存储晶体结构的组，包含所有的原子和晶胞
let isAnimating = false; // 控制晶体是否自动旋转的标志
let atomMaterials = {}; // 存储不同元素的材质，避免重复创建
let raycaster, mouse; // 用于实现射线拾取功能，检测鼠标与3D对象的交互
let atomTooltip; // 显示原子信息的提示框元素
let selectedAtom = null; // 当前选中的原子
let hoveredAtom = null; // 当前悬停的原子

// 元素颜色映射表 - 使用符合学术标准的CPK配色方案
// 为每种化学元素定义特定的颜色，以便在3D视图中区分不同的原子
const elementColors = {
    'H': 0xFFFFFF,   // 氢 - 白色
    'He': 0xD9FFFF,  // 氦 - 浅青色
    'Li': 0xCC80FF,  // 锂 - 紫色
    'Be': 0xC2FF00,  // 铍 - 黄绿色
    'B': 0xFFB5B5,   // 硼 - 浅红色
    'C': 0x909090,   // 碳 - 中灰色
    'N': 0x3050F8,   // 氮 - 深蓝色
    'O': 0xFF0D0D,   // 氧 - 鲜红色
    'F': 0x90E050,   // 氟 - 浅绿色
    'Ne': 0xB3E3F5,  // 氖 - 浅蓝色
    'Na': 0xAB5CF2,  // 钠 - 紫色
    'Mg': 0x8AFF00,  // 镁 - 亮绿色
    'Al': 0xBFA6A6,  // 铝 - 浅灰粉色
    'Si': 0xF0C8A0,  // 硅 - 浅棕色
    'P': 0xFF8000,   // 磷 - 橙色
    'S': 0xFFFF30,   // 硫 - 黄色
    'Cl': 0x1FF01F,  // 氯 - 绿色
    'Ar': 0x80D1E3,  // 氩 - 青色
    'K': 0x8F40D4,   // 钾 - 紫色
    'Ca': 0x3DFF00,  // 钙 - 绿色
    'Sc': 0xE6E6E6,  // 钪 - 浅灰色
    'Ti': 0xBFC2C7,  // 钛 - 灰色
    'V': 0xA6A6AB,   // 钒 - 浅灰色
    'Cr': 0x8A99C7,  // 铬 - 灰蓝色
    'Mn': 0x9C7AC7,  // 锰 - 紫色
    'Fe': 0xE06633,  // 铁 - 棕红色
    'Co': 0xF090A0,  // 钴 - 粉红色
    'Ni': 0x50D050,  // 镍 - 绿色
    'Cu': 0xC88033,  // 铜 - 铜色
    'Zn': 0x7D80B0,  // 锌 - 浅蓝色
    'Ga': 0xC28F8F,  // 镓 - 粉红色
    'Ge': 0x668F8F,  // 锗 - 灰绿色
    'As': 0xBD80E3,  // 砷 - 紫色
    'Se': 0xFFA100,  // 硒 - 橙色
    'Br': 0xA62929,  // 溴 - 棕色
    'Kr': 0x5CB8D1,  // 氪 - 青色
    'Rb': 0x702EB0,  // 铷 - 深紫色
    'Sr': 0x00FF00,  // 锶 - 绿色
    'Y': 0x94FFFF,   // 钇 - 青色
    'Zr': 0x94E0E0,  // 锆 - 浅青色
    'Nb': 0x73C2C9,  // 铌 - 浅青色
    'Mo': 0x54B5B5,  // 钼 - 青色
    'Tc': 0x3B9E9E,  // 锝 - 深青色
    'Ru': 0x248F8F,  // 钌 - 深青色
    'Rh': 0x0A7D8C,  // 铑 - 深青色
    'Pd': 0x006985,  // 钯 - 深青色
    'Ag': 0xC0C0C0,  // 银 - 银色
    'Cd': 0xFFD98F,  // 镉 - 浅黄色
    'In': 0xA67573,  // 铟 - 浅棕色
    'Sn': 0x668080,  // 锡 - 灰青色
    'Sb': 0x9E63B5,  // 锑 - 紫色
    'Te': 0xD47A00,  // 碲 - 棕色
    'I': 0x940094,   // 碘 - 深紫色
    'Xe': 0x429EB0,  // 氙 - 青色
    'Cs': 0x57178F,  // 铯 - 深紫色
    'Ba': 0x00C900,  // 钡 - 深绿色
    'La': 0x70D4FF,  // 镧 - 浅蓝色
    'Ce': 0xFFFFC7,  // 铈 - 浅黄色
    'Pr': 0xD9FFC7,  // 镨 - 浅绿色
    'Nd': 0xC7FFC7,  // 钕 - 浅绿色
    'Pm': 0xA3FFC7,  // 钷 - 浅绿色
    'Sm': 0x8FFFC7,  // 钐 - 浅绿色
    'Eu': 0x61FFC7,  // 铕 - 浅绿色
    'Gd': 0x45FFC7,  // 钆 - 浅绿色
    'Tb': 0x30FFC7,  // 铽 - 浅绿色
    'Dy': 0x1FFFC7,  // 镝 - 浅绿色
    'Ho': 0x00FF9C,  // 钬 - 绿色
    'Er': 0x00E675,  // 铒 - 绿色
    'Tm': 0x00D452,  // 铥 - 绿色
    'Yb': 0x00BF38,  // 镱 - 绿色
    'Lu': 0x00AB24,  // 镥 - 绿色
    'Hf': 0x4DC2FF,  // 铪 - 浅蓝色
    'Ta': 0x4DA6FF,  // 钽 - 浅蓝色
    'W': 0x2194D6,   // 钨 - 蓝色
    'Re': 0x267DAB,  // 铼 - 深蓝色
    'Os': 0x266696,  // 锇 - 深蓝色
    'Ir': 0x175487,  // 铱 - 深蓝色
    'Pt': 0xD0D0E0,  // 铂 - 浅灰色
    'Au': 0xFFD123,  // 金 - 金色
    'Hg': 0xB8B8D0,  // 汞 - 灰色
    'Tl': 0xA6544D,  // 铊 - 棕色
    'Pb': 0x575961,  // 铅 - 深灰色
    'Bi': 0x9E4FB5,  // 铋 - 紫色
    'Po': 0xAB5C00,  // 钋 - 棕色
    'At': 0x754F45,  // 砹 - 深棕色
    'Rn': 0x428296,  // 氡 - 青色
    'Fr': 0x420066,  // 钫 - 深紫色
    'Ra': 0x007D00,  // 镭 - 深绿色
    'Ac': 0x70ABFA,  // 锕 - 浅蓝色
    'Th': 0x00BAFF,  // 钍 - 浅蓝色
    'Pa': 0x00A1FF,  // 镤 - 浅蓝色
    'U': 0x008FFF,   // 铀 - 蓝色
    'Np': 0x0080FF,  // 镎 - 蓝色
    'Pu': 0x006BFF,  // 钚 - 蓝色
    'Am': 0x545CF2,  // 镅 - 蓝色
    'Cm': 0x785CE3,  // 锔 - 紫蓝色
    'Bk': 0x8A4FE3,  // 锫 - 紫色
    'Cf': 0xA136D4,  // 锎 - 紫色
    'Es': 0xB31FD4,  // 锿 - 紫色
    'Fm': 0xB31FBA,  // 镄 - 紫色
    'Md': 0xB30DA6,  // 钔 - 紫色
    'No': 0xBD0D87,  // 锘 - 紫红色
    'Lr': 0xC70066   // 铹 - 紫红色
};

/**
 * 初始化Three.js场景
 * @param {string} containerId - 容器元素ID
 */
function initCrystalViewer(containerId) {
    // 获取DOM容器元素
    const container = document.getElementById(containerId);
    if (!container) {
        // 如果找不到容器元素，输出错误信息并退出
        console.error(`Container element with ID '${containerId}' not found`);
        return;
    }
    
    // 初始化Raycaster和鼠标向量，用于实现鼠标与3D对象的交互
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    
    // 创建原子信息提示框，用于显示被选中原子的详细信息
    atomTooltip = document.createElement('div');
    atomTooltip.className = 'atom-tooltip'; // 设置CSS类名
    atomTooltip.style.display = 'none'; // 初始状态为隐藏
    atomTooltip.style.position = 'absolute'; // 绝对定位
    atomTooltip.style.backgroundColor = 'rgba(30, 30, 30, 0.7)'; // 设置半透明背景色
    atomTooltip.style.color = '#ffffff'; // 设置文字颜色为白色
    atomTooltip.style.padding = '10px'; // 设置内边距
    atomTooltip.style.borderRadius = '5px'; // 设置圆角
    atomTooltip.style.fontSize = '14px'; // 设置字体大小
    atomTooltip.style.zIndex = '1000'; // 设置层级，确保显示在最上层
    atomTooltip.style.pointerEvents = 'none'; // 禁止鼠标事件，使tooltip不影响下层元素的交互
    atomTooltip.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)'; // 添加阴影效果
    atomTooltip.style.minWidth = '150px'; // 设置最小宽度
    atomTooltip.style.backdropFilter = 'blur(5px)'; // 添加背景模糊效果，提升视觉体验
    container.appendChild(atomTooltip); // 添加到容器中
    
    // 添加原子提示框样式，定义更详细的CSS样式
    const tooltipStyle = document.createElement('style');
    tooltipStyle.textContent = `
        .atom-tooltip .element-symbol {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        .atom-tooltip .element-details {
            font-size: 12px;
        }
        .atom-tooltip .element-details div {
            margin: 3px 0;
        }
    `;
    document.head.appendChild(tooltipStyle); // 将样式添加到文档头部

    // 获取容器尺寸，用于设置渲染器和相机
    const width = container.clientWidth;
    const height = container.clientHeight || 400; // 如果高度未定义，使用默认值400px

    // 创建Three.js场景
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); // 设置场景背景为白色

    // 创建透视相机
    camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
    camera.position.z = 10; // 设置相机初始位置

    // 创建WebGL渲染器
    renderer = new THREE.WebGLRenderer({ 
        antialias: true, // 启用抗锯齿，提升画面质量
        preserveDrawingBuffer: true // 保留绘图缓冲区，支持截图功能
    }); 
    renderer.setSize(width, height); // 设置渲染器尺寸
    renderer.setPixelRatio(window.devicePixelRatio); // 设置设备像素比，适应高分辨率屏幕
    container.appendChild(renderer.domElement); // 将渲染器的DOM元素添加到容器中

    // 添加轨道控制器，实现相机绕物体旋转、平移和缩放功能
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // 启用阻尼效果，使控制更平滑
    controls.dampingFactor = 0.25; // 设置阻尼系数
    controls.screenSpacePanning = false; // 禁用屏幕空间平移
    controls.maxDistance = 100; // 设置最大缩放距离
    controls.addEventListener('change', function() {
        // 控制器变化时，确保更新射线以修复悬停问题
        updateRaycasterFromMouse();
    });
    controls.update(); // 更新控制器

    // 添加光照系统
    // 添加环境光，提供基础环境光照
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    // 添加半球光以提供更自然的照明效果，模拟环境光反射
    const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xbbbbbb, 0.3);
    scene.add(hemisphereLight);

    // 添加方向光提供适度的阴影和立体感，增强3D效果
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(1, 1, 1).normalize(); // 设置光源方向
    scene.add(directionalLight);

    // 创建晶体结构的容器组，所有原子和晶胞框架都将添加到这个组中
    crystalGroup = new THREE.Group();
    scene.add(crystalGroup);

    // 添加增强的坐标轴辅助，帮助用户理解3D空间方向
    addEnhancedAxesHelper();
    
    // 创建功能工具栏，提供用户交互界面
    createToolbar(container);
    
    // 创建扩胞控制面板，用于调整晶胞显示
    createSupercellPanel(container);

    // 开始动画循环，不断更新场景渲染
    animate();

    // 添加窗口大小调整事件处理程序，确保画面自适应
    window.addEventListener('resize', () => {
        const width = container.clientWidth;
        const height = container.clientHeight || 400;
        
        camera.aspect = width / height; // 更新相机宽高比
        camera.updateProjectionMatrix(); // 更新相机投影矩阵
        renderer.setSize(width, height); // 调整渲染器尺寸
    });
    
    // 添加点击事件监听器 - 仅需点击事件，不需要悬停事件
    renderer.domElement.addEventListener('click', onAtomClick);
    
    // 添加鼠标移动事件用于获取光标位置，但不显示悬停效果
    renderer.domElement.addEventListener('mousemove', function(event) {
        // 更新鼠标位置但不显示悬停效果
        updateMousePosition(event);
    });
}

/**
 * 创建功能工具栏
 * @param {HTMLElement} container - 容器元素
 */
function createToolbar(container) {
    // 创建工具栏的DOM容器
    const toolbar = document.createElement('div');
    toolbar.className = 'crystal-toolbar'; // 设置CSS类名便于样式调整
    toolbar.style.position = 'absolute'; // 使用绝对定位
    toolbar.style.top = '10px'; // 距顶部10px
    toolbar.style.right = '10px'; // 定位在右上角
    toolbar.style.display = 'flex'; // 使用flex布局排列按钮
    toolbar.style.gap = '10px'; // 按钮之间的间距
    toolbar.style.zIndex = '1000'; // 设置层级确保在上层显示
    
    // 创建截图按钮
    const screenshotBtn = document.createElement('button');
    screenshotBtn.innerHTML = '<i class="fas fa-camera"></i>'; // 使用Font Awesome图标
    screenshotBtn.title = '截图'; // 设置鼠标悬停提示文字
    screenshotBtn.className = 'toolbar-btn'; // 设置CSS类名
    screenshotBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.8)'; // 半透明白色背景
    screenshotBtn.style.border = 'none'; // 无边框
    screenshotBtn.style.borderRadius = '5px'; // 圆角边框
    screenshotBtn.style.padding = '8px'; // 内边距
    screenshotBtn.style.cursor = 'pointer'; // 鼠标悬停时显示手型光标
    screenshotBtn.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.1)'; // 添加阴影效果
    screenshotBtn.addEventListener('click', takeScreenshot); // 添加点击事件监听器
    toolbar.appendChild(screenshotBtn); // 将按钮添加到工具栏
    
    // 创建下载CIF文件按钮
    const downloadCIFBtn = document.createElement('button');
    downloadCIFBtn.innerHTML = '<i class="fas fa-download"></i>'; // 使用下载图标
    downloadCIFBtn.title = '下载CIF文件'; // 设置提示文字
    downloadCIFBtn.className = 'toolbar-btn';
    downloadCIFBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    downloadCIFBtn.style.border = 'none';
    downloadCIFBtn.style.borderRadius = '5px';
    downloadCIFBtn.style.padding = '8px';
    downloadCIFBtn.style.cursor = 'pointer';
    downloadCIFBtn.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.1)';
    downloadCIFBtn.addEventListener('click', downloadCIFFile); // 添加下载CIF文件的点击事件
    toolbar.appendChild(downloadCIFBtn);
    
    // 创建重置视图按钮
    const resetViewBtn = document.createElement('button');
    resetViewBtn.innerHTML = '<i class="fas fa-redo-alt"></i>'; // 使用重置图标
    resetViewBtn.title = '重置视图'; // 设置提示文字
    resetViewBtn.className = 'toolbar-btn';
    resetViewBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    resetViewBtn.style.border = 'none';
    resetViewBtn.style.borderRadius = '5px';
    resetViewBtn.style.padding = '8px';
    resetViewBtn.style.cursor = 'pointer';
    resetViewBtn.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.1)';
    resetViewBtn.addEventListener('click', resetView); // 添加重置视图的点击事件
    toolbar.appendChild(resetViewBtn);
    
    // 创建背景色选择按钮（带下拉菜单）
    const bgColorContainer = document.createElement('div');
    bgColorContainer.className = 'bg-color-container';
    bgColorContainer.style.position = 'relative'; // 设为相对定位，作为下拉菜单的参考点
    
    // 创建背景色按钮
    const bgColorBtn = document.createElement('button');
    bgColorBtn.innerHTML = '<i class="fas fa-palette"></i>'; // 使用调色板图标
    bgColorBtn.title = '切换背景色'; // 设置提示文字
    bgColorBtn.className = 'toolbar-btn';
    bgColorBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    bgColorBtn.style.border = 'none';
    bgColorBtn.style.borderRadius = '5px';
    bgColorBtn.style.padding = '8px';
    bgColorBtn.style.cursor = 'pointer';
    bgColorBtn.style.boxShadow = '0 2px 5px rgba(0, 0, 0, 0.1)';
    
    // 创建背景色下拉菜单
    const bgColorDropdown = document.createElement('div');
    bgColorDropdown.className = 'bg-color-dropdown';
    bgColorDropdown.style.position = 'absolute'; // 绝对定位
    bgColorDropdown.style.top = '100%'; // 定位在按钮下方
    bgColorDropdown.style.right = '0'; // 右对齐
    bgColorDropdown.style.backgroundColor = 'white'; // 白色背景
    bgColorDropdown.style.borderRadius = '5px'; // 圆角边框
    bgColorDropdown.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)'; // 阴影效果
    bgColorDropdown.style.display = 'none'; // 初始状态为隐藏
    bgColorDropdown.style.zIndex = '1001'; // 确保显示在最上层
    bgColorDropdown.style.marginTop = '5px'; // 与按钮保持间距
    bgColorDropdown.style.width = '150px'; // 设置下拉菜单宽度
    
    // 定义可选的背景色选项
    const colorOptions = [
        { label: '白色背景', value: 'white', color: '#ffffff' },
        { label: '黑色背景', value: 'black', color: '#000000' },
        { label: '透明背景', value: 'transparent', color: 'transparent' }
    ];
    
    // 为每个颜色选项创建DOM元素
    colorOptions.forEach(option => {
        // 创建颜色选项容器
        const colorOption = document.createElement('div');
        colorOption.className = 'color-option';
        colorOption.style.display = 'flex'; // 使用flex布局
        colorOption.style.alignItems = 'center'; // 垂直居中对齐
        colorOption.style.padding = '8px 12px'; // 内边距
        colorOption.style.cursor = 'pointer'; // 鼠标悬停时显示手型光标
        colorOption.style.borderBottom = '1px solid #eee'; // 底部分隔线
        
        // 创建颜色预览框
        const colorPreview = document.createElement('div');
        colorPreview.className = 'color-preview';
        colorPreview.style.width = '16px'; // 设置宽度
        colorPreview.style.height = '16px'; // 设置高度
        colorPreview.style.marginRight = '10px'; // 右侧间距
        colorPreview.style.borderRadius = '3px'; // 圆角边框
        colorPreview.style.border = '1px solid #ddd'; // 边框
        
        // 如果是透明背景，使用特殊样式表示
        if (option.value === 'transparent') {
            // 为透明背景添加特殊样式，使用棋盘格图案表示透明度
            colorPreview.style.background = 'linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc), linear-gradient(45deg, #ccc 25%, transparent 25%, transparent 75%, #ccc 75%, #ccc)';
            colorPreview.style.backgroundSize = '8px 8px';
            colorPreview.style.backgroundPosition = '0 0, 4px 4px';
        } else {
            // 为其他背景设置对应的颜色
            colorPreview.style.backgroundColor = option.color;
        }
        
        // 创建选项标签文本
        const optionLabel = document.createElement('span');
        optionLabel.textContent = option.label; // 设置显示文本
        
        // 将预览框和标签添加到选项容器
        colorOption.appendChild(colorPreview);
        colorOption.appendChild(optionLabel);
        
        // 添加悬停效果，鼠标移入时改变背景色
        colorOption.addEventListener('mouseover', () => {
            colorOption.style.backgroundColor = '#f5f5f5';
        });
        
        // 鼠标移出时恢复原背景色
        colorOption.addEventListener('mouseout', () => {
            colorOption.style.backgroundColor = 'white';
        });
        
        // 添加点击事件，切换背景色并隐藏下拉菜单
        colorOption.addEventListener('click', () => {
            toggleBackgroundColor(option.value); // 调用切换背景色函数
            bgColorDropdown.style.display = 'none'; // 隐藏下拉菜单
        });
        
        // 将颜色选项添加到下拉菜单
        bgColorDropdown.appendChild(colorOption);
    });
    
    // 处理下拉菜单的显示和隐藏
    bgColorBtn.addEventListener('click', () => {
        // 切换下拉菜单的显示状态
        if (bgColorDropdown.style.display === 'none') {
            bgColorDropdown.style.display = 'block';
        } else {
            bgColorDropdown.style.display = 'none';
        }
    });
    
    // 添加点击外部区域关闭下拉菜单的事件监听
    document.addEventListener('click', (event) => {
        // 如果点击的不是背景色按钮区域，则隐藏下拉菜单
        if (!bgColorContainer.contains(event.target)) {
            bgColorDropdown.style.display = 'none';
        }
    });
    
    // 将按钮和下拉菜单添加到容器中
    bgColorContainer.appendChild(bgColorBtn);
    bgColorContainer.appendChild(bgColorDropdown);
    toolbar.appendChild(bgColorContainer);
    
    // 将工具栏添加到主容器中
    container.appendChild(toolbar);
}

/**
 * 截图并保存
 * 将当前晶体结构的视图保存为PNG图片
 */
function takeScreenshot() {
    // 从渲染器获取图像数据，转换为PNG格式的Data URL
    const imgData = renderer.domElement.toDataURL('image/png');
    
    // 创建下载链接
    const link = document.createElement('a');
    link.href = imgData; // 设置链接地址为图像数据
    link.download = 'crystal-structure.png'; // 设置下载的文件名
    document.body.appendChild(link); // 将链接添加到文档
    link.click(); // 模拟点击链接触发下载
    document.body.removeChild(link); // 下载后移除链接
}

/**
 * 设置背景颜色
 * @param {string} type - 背景类型: 'white'(白色), 'black'(黑色), 或 'transparent'(透明)
 */
function setBackgroundColor(type) {
    switch (type) {
        case 'white':
            // 设置为白色背景
            scene.background = new THREE.Color(0xffffff);
            break;
        case 'black':
            // 设置为黑色背景
            scene.background = new THREE.Color(0x000000);
            break;
        case 'transparent':
            // 设置为透明背景，适用于截图叠加
            scene.background = null;
            renderer.setClearColor(0x000000, 0); // 设置清除颜色为透明
            break;
        default:
            // 默认为白色背景
            scene.background = new THREE.Color(0xffffff);
    }
}

/**
 * 更新鼠标光标位置
 * 跟踪鼠标在渲染区域中的位置坐标，转换为Three.js中的标准化坐标系
 * @param {Event} event - 鼠标事件对象
 */
function updateMousePosition(event) {
    // 获取渲染区域的边界矩形，用于计算相对位置
    const rect = renderer.domElement.getBoundingClientRect();
    // 将鼠标位置转换为标准化设备坐标系，范围在-1到1之间
    // X坐标：从左到右为-1到1
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    // Y坐标：从上到下为1到-1（注意Y轴是反的）
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
}

/**
 * 更新光线发射器，用于修复旋转后悬停问题
 * 在相机视角变化后重新设置射线，确保交互正确
 */
function updateRaycasterFromMouse() {
    // 如果有选中的原子，更新射线以保持提示框位置正确
    if (selectedAtom) {
        // 根据当前鼠标位置和相机设置射线
        raycaster.setFromCamera(mouse, camera);
    // 更新提示框位置
    updateTooltipPosition();
    }
}

/**
 * 处理原子点击事件
 * 实现原子的选择、取消选择，并显示相关信息
 * @param {Event} event - 点击事件对象
 */
function onAtomClick(event) {
    // 更新鼠标位置坐标
    updateMousePosition(event);
    
    // 根据鼠标位置设置射线
    raycaster.setFromCamera(mouse, camera);
    
    // 获取与射线相交的3D对象，即检测是否点击到原子
    const intersects = raycaster.intersectObjects(crystalGroup.children);
    
    // 如果点击到了原子
    if (intersects.length > 0) {
        const atom = intersects[0].object;
        // 确认点击的是原子对象（具有element属性）
        if (atom.userData.element) {
            // 如果点击的是已选中的原子
            if (selectedAtom === atom) {
                // 取消选中状态
                resetAtomMaterial(atom); // 恢复原子材质
                selectedAtom = null; // 清除选中的原子引用
                atomTooltip.style.display = 'none'; // 隐藏提示框
            } else {
                // 如果点击的是新原子，但之前已有选中的原子
                if (selectedAtom) {
                    // 重置之前选中原子的材质
                    resetAtomMaterial(selectedAtom);
                }
                // 选中新的原子
                selectedAtom = atom;
                highlightAtom(atom); // 高亮显示选中的原子
                
                // 填充提示框内容，显示原子的详细信息
                const element = atom.userData.element; // 元素符号
                const position = atom.userData.position; // 原子位置
                const properties = atom.userData.properties || {}; // 原子属性
                
                // 使用HTML设置提示框内容
                atomTooltip.innerHTML = `
                    <div class="element-symbol">${element}</div>
                    <div class="element-details">
                        <div>Position: (${position[0].toFixed(3)}, ${position[1].toFixed(3)}, ${position[2].toFixed(3)})</div>
                        ${properties.charge ? `<div>Charge: ${properties.charge}</div>` : ''}
                        ${properties.coordination ? `<div>Coordination: ${properties.coordination}</div>` : ''}
                    </div>
                `;
                atomTooltip.style.display = 'block'; // 显示提示框
                updateTooltipPosition(); // 更新提示框位置
            }
        }
    } else {
        // 点击空白处，取消选中状态
        if (selectedAtom) {
            resetAtomMaterial(selectedAtom); // 恢复原子材质
            selectedAtom = null; // 清除选中的原子引用
            atomTooltip.style.display = 'none'; // 隐藏提示框
        }
    }
}

/**
 * 动画循环
 * 实现持续渲染和更新，创建平滑的交互体验
 */
function animate() {
    // 请求下一帧动画，创建无限循环
    requestAnimationFrame(animate);
    
    // 更新控制器状态，实现阻尼效果
    controls.update();
    
    // 如果启用了自动旋转，旋转晶体结构
    if (isAnimating && crystalGroup) {
        crystalGroup.rotation.y += 0.005; // 每帧旋转一小角度
    }
    
    // 更新选中原子信息提示框位置，跟随原子移动
    if (selectedAtom && atomTooltip.style.display !== 'none') {
                updateTooltipPosition();
            }
    
    // 渲染当前场景，更新显示
    renderer.render(scene, camera);
}

/**
 * 高亮显示选中的原子
 * 通过改变材质和添加轮廓效果使选中的原子更突出
 * @param {THREE.Object3D} atom - 要高亮显示的原子对象
 */
function highlightAtom(atom) {
    // 保存原有材质，以便之后恢复
    if (!atom.userData.originalMaterial) {
        atom.userData.originalMaterial = atom.material;
    }

    // 创建高亮材质 - 使用原子的基本颜色但更加明亮
    const color = atom.material.color.clone();
    
    // 选中状态 - 使用发光材质使原子更突出
    atom.material = new THREE.MeshStandardMaterial({
        color: color.clone().multiplyScalar(1.3), // 增加颜色亮度
        emissive: color.clone().multiplyScalar(0.3), // 添加自发光效果
        emissiveIntensity: 0.5, // 设置自发光强度
        metalness: 0.3, // 增加金属感
        roughness: 0.5, // 降低粗糙度，增加光泽
        flatShading: false // 使用平滑着色
    });
    
    // 添加边框效果，进一步增强选中效果
    if (!atom.userData.outline) {
        // 获取原子半径，稍微放大用于边框
        const radius = atom.geometry.parameters.radius * 1.1;
        
        // 创建边框几何体和材质
        const outlineGeometry = new THREE.SphereGeometry(radius, 32, 32);
        const outlineMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff, // 白色边框
            side: THREE.BackSide, // 使用背面渲染，形成轮廓效果
            transparent: true, // 启用透明度
            opacity: 0.3 // 设置透明度
        });
        
        // 创建边框网格并添加到原子对象
        const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
        atom.add(outline); // 将边框添加为原子的子对象
        atom.userData.outline = outline; // 保存边框引用以便后续操作
    }
}

/**
 * 重置原子材质
 * 取消高亮显示，恢复原子的原始外观
 * @param {THREE.Object3D} atom - 要重置的原子对象
 */
function resetAtomMaterial(atom) {
    // 如果有保存的原始材质，则恢复
    if (atom.userData.originalMaterial) {
        atom.material = atom.userData.originalMaterial;
        atom.userData.originalMaterial = null; // 清除保存的材质引用
    }
    
    // 移除边框效果
    if (atom.userData.outline) {
        atom.remove(atom.userData.outline); // 从原子移除边框对象
        atom.userData.outline = null; // 清除边框引用
    }
    
    // 重置脉冲动画状态（如果有）
    if (atom.userData.pulseAnimation) {
        atom.scale.set(1, 1, 1); // 重置原子缩放
        atom.userData.pulseAnimation = null; // 清除动画引用
    }
}

/**
 * 更新提示框位置
 * 确保提示框跟随选中的原子位置
 */
function updateTooltipPosition() {
    // 如果提示框已隐藏或没有选中的原子，则不更新
    if (atomTooltip.style.display === 'none' || !selectedAtom) return;
    
    // 将原子的3D坐标转换为屏幕坐标
    const vector = new THREE.Vector3();
    vector.setFromMatrixPosition(selectedAtom.matrixWorld); // 获取原子在世界坐标系中的位置
    vector.project(camera); // 将3D坐标投影到2D屏幕坐标
    
    // 转换为CSS像素坐标
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
        
    // 更新提示框位置，显示在原子上方
        atomTooltip.style.left = `${x}px`;
    atomTooltip.style.top = `${y - 30}px`; // 向上偏移30像素，避免遮挡原子
}

/**
 * 加载晶体结构数据
 * 通过API获取指定材料ID的晶体结构数据并渲染
 * @param {number} materialId - 材料ID，用于API请求
 */
function loadCrystalStructure(materialId) {
    // 显示加载指示器，提示用户正在加载数据
    showLoadingIndicator();
    
    // 从API获取结构数据
    fetch(`/api/structure/${materialId}`)
        .then(response => {
            // 检查API响应状态
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json(); // 将响应解析为JSON
        })
        .then(data => {
            // 数据加载成功，隐藏加载指示器
            hideLoadingIndicator();
            
            // 渲染晶体结构
            renderCrystalStructure(data);
        })
        .catch(error => {
            // 处理错误情况
            console.error('Error loading crystal structure:', error);
            hideLoadingIndicator(); // 隐藏加载指示器
            showErrorMessage('Failed to load crystal structure data'); // 显示错误信息
        });
}

/**
 * 渲染晶体结构
 * 根据获取的数据创建3D晶体模型
 * @param {Object} structureData - 晶体结构数据，包含晶格和原子信息
 */
function renderCrystalStructure(structureData) {
    // 清除现有结构，避免重叠显示
    while (crystalGroup.children.length > 0) {
        const object = crystalGroup.children[0];
        object.geometry.dispose(); // 释放几何体资源
        object.material.dispose(); // 释放材质资源
        crystalGroup.remove(object); // 从场景中移除对象
    }

    // 添加晶格框架，显示晶胞边界
    addUnitCell(structureData.lattice);
    
    // 遍历所有原子数据，添加到场景中
    structureData.atoms.forEach(atom => {
        addAtom(atom);
    });

    // 重置相机位置以适应整个结构
    resetCameraPosition(structureData);
    
    // 添加标题和原子图例，增强可视化效果
    addTitleAndLegend(structureData);
}

/**
 * 添加单位晶胞框架
 * 根据晶格参数绘制晶胞的边框
 * @param {Object} lattice - 晶格参数，包含矩阵信息
 */
function addUnitCell(lattice) {
    const matrix = lattice.matrix; // 获取晶格矩阵
    
    // 创建晶胞八个顶点的坐标
    // 使用向量表示，基于晶格矩阵中的基矢量
    const vertices = [
        new THREE.Vector3(0, 0, 0), // 原点
        new THREE.Vector3(matrix[0][0], matrix[0][1], matrix[0][2]), // a方向
        new THREE.Vector3(matrix[1][0], matrix[1][1], matrix[1][2]), // b方向
        new THREE.Vector3(matrix[0][0] + matrix[1][0], matrix[0][1] + matrix[1][1], matrix[0][2] + matrix[1][2]), // a+b
        new THREE.Vector3(matrix[2][0], matrix[2][1], matrix[2][2]), // c方向
        new THREE.Vector3(matrix[0][0] + matrix[2][0], matrix[0][1] + matrix[2][1], matrix[0][2] + matrix[2][2]), // a+c
        new THREE.Vector3(matrix[1][0] + matrix[2][0], matrix[1][1] + matrix[2][1], matrix[1][2] + matrix[2][2]), // b+c
        new THREE.Vector3(matrix[0][0] + matrix[1][0] + matrix[2][0], matrix[0][1] + matrix[1][1] + matrix[2][1], matrix[0][2] + matrix[1][2] + matrix[2][2]) // a+b+c
    ];

    // 定义晶胞的12条边，每条边由两个顶点的索引表示
    const edges = [
        [0, 1], [0, 2], [1, 3], [2, 3], // 底面的四条边
        [0, 4], [1, 5], [2, 6], [3, 7], // 连接底面和顶面的四条边
        [4, 5], [4, 6], [5, 7], [6, 7]  // 顶面的四条边
    ];

    // 创建线条几何体，用于绘制晶胞边框
    const geometry = new THREE.BufferGeometry();
    const positions = []; // 存储顶点坐标

    // 将每条边的两个顶点坐标添加到positions数组
    edges.forEach(edge => {
        positions.push(
            vertices[edge[0]].x, vertices[edge[0]].y, vertices[edge[0]].z, // 第一个顶点
            vertices[edge[1]].x, vertices[edge[1]].y, vertices[edge[1]].z  // 第二个顶点
        );
    });

    // 将坐标数组设置为几何体的属性
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

    // 创建线条材质，设置为黑色细线
    const material = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 });

    // 创建线段对象并添加到晶体组
    const unitCell = new THREE.LineSegments(geometry, material);
    crystalGroup.add(unitCell); // 将晶胞边框添加到晶体组
}

/**
 * 添加原子
 * 创建表示原子的彩色球体
 * @param {Object} atom - 原子数据，包含元素类型、位置和属性
 */
function addAtom(atom) {
    const element = atom.element; // 获取元素符号
    const position = atom.position; // 获取原子位置坐标
    const radius = atom.properties.radius || 0.5; // 获取原子半径，如果未定义则使用默认值
    
    // 获取元素颜色，如果未定义则使用默认的灰色
    const color = elementColors[element] || 0x808080;
    
    // 创建或重用材质 - 使用MeshStandardMaterial提供更好的学术显示效果
    if (!atomMaterials[element]) {
        // 如果此元素的材质不存在，创建新材质
        atomMaterials[element] = new THREE.MeshStandardMaterial({
            color: color, // 设置颜色
            metalness: 0.2,    // 低金属感
            roughness: 0.7,    // 较高粗糙度，减少强反射
            emissive: new THREE.Color(color).multiplyScalar(0.1), // 轻微自发光
            emissiveIntensity: 0.2, // 低自发光强度
            flatShading: false // 平滑着色
        });
    }
    
    // 创建球体几何体表示原子 - 增加细分以获得更光滑的外观
    const geometry = new THREE.SphereGeometry(radius * 0.5, 32, 32);
    
    // 创建网格对象并设置位置
    const mesh = new THREE.Mesh(geometry, atomMaterials[element]);
    mesh.position.set(position[0], position[1], position[2]); // 设置原子位置
    
    // 添加轮廓以增强原子间的区分度
    const outlineGeometry = new THREE.SphereGeometry(radius * 0.53, 32, 32); // 稍大一点的球体作为轮廓
    const outlineMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000, // 黑色轮廓
        side: THREE.BackSide, // 背面渲染
        transparent: true, // 启用透明度
        opacity: 0.1 // 低透明度
    });
    
    // 创建轮廓网格并添加为原子的子对象
    const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
    mesh.add(outline);
    
    // 添加用户数据（用于交互），存储原子的相关信息
    mesh.userData = {
        element: element, // 元素符号
        position: position, // 位置坐标
        properties: atom.properties // 原子属性
    };
    
    // 将原子添加到晶体组
    crystalGroup.add(mesh);
}

/**
 * 重置相机位置以适应结构
 * 根据晶体结构的大小自动调整相机位置和视角
 * @param {Object} structureData - 晶体结构数据
 */
function resetCameraPosition(structureData) {
    // 计算结构的边界框
    const boundingBox = new THREE.Box3().setFromObject(crystalGroup);
    const center = boundingBox.getCenter(new THREE.Vector3());
    const size = boundingBox.getSize(new THREE.Vector3());
    
    // 计算适当的相机距离
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI / 180);
    let cameraDistance = (maxDim / 2) / Math.tan(fov / 2);
    
    // 设置相机位置
    camera.position.set(center.x, center.y, center.z + cameraDistance * 1.5);
    camera.lookAt(center);
    
    // 更新控制器目标点
    controls.target.copy(center);
    controls.update();
}

/**
 * 显示加载指示器
 */
function showLoadingIndicator() {
    // Check if loading indicator already exists
    let loadingIndicator = document.getElementById('loading-indicator');
    
    // If not, create new loading indicator
    if (!loadingIndicator) {
        loadingIndicator = document.createElement('div');
        loadingIndicator.id = 'loading-indicator';
    loadingIndicator.style.position = 'absolute';
    loadingIndicator.style.top = '50%';
    loadingIndicator.style.left = '50%';
    loadingIndicator.style.transform = 'translate(-50%, -50%)';
        loadingIndicator.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    loadingIndicator.style.padding = '20px';
        loadingIndicator.style.borderRadius = '10px';
        loadingIndicator.style.display = 'flex';
        loadingIndicator.style.flexDirection = 'column';
        loadingIndicator.style.alignItems = 'center';
        loadingIndicator.style.justifyContent = 'center';
        loadingIndicator.style.zIndex = '2000';
        loadingIndicator.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        
        // Add spinner animation
        const spinner = document.createElement('div');
        spinner.style.width = '40px';
        spinner.style.height = '40px';
        spinner.style.border = '4px solid #f3f3f3';
        spinner.style.borderTop = '4px solid #3498db';
        spinner.style.borderRadius = '50%';
        spinner.style.animation = 'spin 1s linear infinite';
        
        // Add keyframes animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
        
        // Add text
        const text = document.createElement('div');
        text.textContent = 'Loading...';
        text.style.marginTop = '10px';
        
        loadingIndicator.appendChild(spinner);
        loadingIndicator.appendChild(text);
        
        const viewerContainer = document.querySelector('.crystal-viewer');
        if (viewerContainer) {
            viewerContainer.appendChild(loadingIndicator);
        } else {
            document.body.appendChild(loadingIndicator);
        }
    } else {
        loadingIndicator.style.display = 'flex';
    }
}

/**
 * 隐藏加载指示器
 */
function hideLoadingIndicator() {
    const loadingIndicator = document.getElementById('loading-indicator');
    if (loadingIndicator) {
        loadingIndicator.style.display = 'none';
    }
}

/**
 * 添加标题和原子图例
 * 在3D视图上方显示晶体结构的名称，在左侧显示元素图例
 * @param {Object} structureData - 晶体结构数据
 */
function addTitleAndLegend(structureData) {
    // 获取渲染器的父元素容器
    const container = renderer.domElement.parentElement;
    container.style.position = 'relative'; // 设置为相对定位，作为子元素的定位参考
    
    // 移除已存在的标题和图例（如果有），避免重复显示
    const existingTitle = document.getElementById('crystal-title');
    if (existingTitle) existingTitle.remove();
    
    const existingLegend = document.getElementById('crystal-legend');
    if (existingLegend) existingLegend.remove();
    
    // 创建标题元素，显示晶体结构的名称
    const titleElement = document.createElement('div');
    titleElement.id = 'crystal-title'; // 设置ID便于后续引用
    titleElement.className = 'crystal-title'; // 设置CSS类名
    titleElement.innerHTML = `<h3>Crystal Structure - ${structureData.formula}</h3>`; // 显示晶体化学式
    container.appendChild(titleElement); // 添加到容器
    
    // 统计每种元素的原子数量，用于图例显示
    const elementCounts = {};
    structureData.atoms.forEach(atom => {
        const element = atom.element;
        if (!elementCounts[element]) {
            elementCounts[element] = 1; // 如果是第一次遇到此元素，计数为1
        } else {
            elementCounts[element]++; // 增加计数
        }
    });
    
    // 创建图例面板，显示不同元素及其颜色
    const legendElement = document.createElement('div');
    legendElement.id = 'crystal-legend'; // 设置ID
    legendElement.className = 'crystal-legend'; // 设置CSS类名
    
    // 添加图例标题
    const legendTitle = document.createElement('div');
    legendTitle.className = 'legend-title';
    legendTitle.textContent = 'Atom Legend'; // 图例标题文本
    legendElement.appendChild(legendTitle);
    
    // 添加每种元素的图例项
    const legendItems = document.createElement('div');
    legendItems.className = 'legend-items';
    
    // 按元素符号字母顺序排序，使图例有序
    const sortedElements = Object.keys(elementCounts).sort();
    
    // 为每种元素创建图例项
    sortedElements.forEach(element => {
        const count = elementCounts[element]; // 获取元素数量
        const color = elementColors[element] || 0x808080; // 获取元素颜色
        
        // 创建单个图例项
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        
        // 创建颜色示例，显示元素的颜色
        const colorSample = document.createElement('div');
        colorSample.className = 'color-sample';
        colorSample.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`; // 转换16进制颜色为CSS颜色
        legendItem.appendChild(colorSample);
        
        // 创建元素名称和数量文本
        const elementInfo = document.createElement('div');
        elementInfo.className = 'element-info';
        elementInfo.textContent = `${element}: ${count} atoms`; // 显示"元素: 数量 atoms"
        legendItem.appendChild(elementInfo);
        
        // 添加到图例项容器
        legendItems.appendChild(legendItem);
    });
    
    // 将图例项容器添加到图例元素
    legendElement.appendChild(legendItems);
    // 将图例元素添加到主容器
    container.appendChild(legendElement);
    
    // 添加CSS样式，定义标题和图例的外观
    const style = document.createElement('style');
    style.textContent = `
        .crystal-title {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%); /* 水平居中 */
            background-color: rgba(255, 255, 255, 0.8); /* 半透明背景 */
            padding: 5px 15px;
            border-radius: 5px;
            z-index: 100;
            text-align: center;
        }
        
        .crystal-title h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }
        
        .crystal-legend {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 200px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            font-size: 14px;
            color: #333;
        }
        
        .legend-items {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-sample {
            width: 15px;
            height: 15px;
            border-radius: 50%; /* 圆形颜色样本 */
            border: 1px solid #ddd;
        }
        
        .element-info {
            font-size: 12px;
            color: #333;
        }
        
        /* 响应式设计，在小屏幕上调整大小和位置 */
        @media (max-width: 600px) {
            .crystal-legend {
                top: 10px;
                left: 10px;
                max-width: 150px;
            }
            
            .crystal-title {
                top: 5px;
                padding: 3px 10px;
            }
            
            .crystal-title h3 {
                font-size: 14px;
            }
        }
    `;
    document.head.appendChild(style); // 将样式添加到文档头部
}

/**
 * 显示错误消息
 * 在界面上显示操作错误提示，几秒后自动消失
 * @param {string} message - 错误消息文本
 */
function showErrorMessage(message) {
    // 检查是否已存在错误消息框
    let errorMessage = document.getElementById('error-message');
    
    // 如果不存在，创建新的错误消息框
    if (!errorMessage) {
        errorMessage = document.createElement('div');
        errorMessage.id = 'error-message'; // 设置ID
        errorMessage.style.position = 'absolute'; // 绝对定位
        errorMessage.style.top = '20px'; // 顶部距离
        errorMessage.style.left = '50%'; // 水平居中
        errorMessage.style.transform = 'translateX(-50%)'; // 精确居中
        errorMessage.style.backgroundColor = 'rgba(220, 53, 69, 0.9)'; // 半透明红色背景
        errorMessage.style.color = 'white'; // 白色文字
        errorMessage.style.padding = '10px 20px'; // 内边距
        errorMessage.style.borderRadius = '5px'; // 圆角边框
        errorMessage.style.zIndex = '2000'; // 确保显示在最上层
        errorMessage.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)'; // 阴影效果
        errorMessage.style.minWidth = '200px'; // 最小宽度
        errorMessage.style.textAlign = 'center'; // 文字居中
        
        // 将错误消息框添加到视图容器或文档主体
        const viewerContainer = document.querySelector('.crystal-viewer');
        if (viewerContainer) {
            viewerContainer.appendChild(errorMessage);
        } else {
            document.body.appendChild(errorMessage);
        }
    }
    
    // 更新错误消息文本
    errorMessage.textContent = message;
    errorMessage.style.display = 'block'; // 显示错误消息
    
    // 3秒后自动隐藏错误消息
    setTimeout(() => {
        errorMessage.style.display = 'none';
    }, 3000);
}

/**
 * 控制功能：向左旋转
 * 将晶体结构绕Y轴向左旋转15度
 */
function rotateLeft() {
    // 绕Y轴逆时针旋转π/12弧度（15度）
    crystalGroup.rotation.y -= Math.PI / 12;
}

/**
 * 控制功能：向右旋转
 * 将晶体结构绕Y轴向右旋转15度
 */
function rotateRight() {
    // 绕Y轴顺时针旋转π/12弧度（15度）
    crystalGroup.rotation.y += Math.PI / 12;
}

/**
 * 控制功能：重置视图
 * 将晶体结构恢复到初始位置和方向
 */
function resetView() {
    // 重置晶体组的旋转
    crystalGroup.rotation.set(0, 0, 0);
    // 重置轨道控制器，恢复初始视角
    controls.reset();
}

/**
 * 控制功能：切换自动旋转
 * 启用或禁用晶体结构的自动旋转动画
 */
function toggleSpin() {
    // 反转动画状态标志
    isAnimating = !isAnimating;
}

/**
 * 添加增强的坐标轴辅助
 * 创建带标签和箭头的3D坐标轴，显示在视图左下角
 */
function addEnhancedAxesHelper() {
    // 移除现有的坐标轴辅助，避免重复显示
    scene.children.forEach(child => {
        if (child instanceof THREE.AxesHelper) {
            scene.remove(child);
        }
    });
    
    // 创建自定义坐标轴组，作为所有轴元素的容器
    const axesGroup = new THREE.Group();
    axesGroup.position.set(-4.5, -4.5, -4.5); // 放置在左下角
    
    // 设置轴的长度和宽度
    const axisLength = 3; // 轴长度
    const axisWidth = 0.1; // 轴宽度
    
    // 创建X轴（红色）
    const xAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 16);
    xAxisGeometry.rotateZ(-Math.PI / 2); // 旋转使圆柱体沿X轴方向
    const xAxisMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000, metalness: 0.5, roughness: 0.5 });
    const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
    xAxis.position.set(axisLength / 2, 0, 0); // 定位X轴
    
    // 创建Y轴（绿色）
    const yAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 16);
    // Y轴不需要旋转，默认就是垂直的
    const yAxisMaterial = new THREE.MeshStandardMaterial({ color: 0x00FF00, metalness: 0.5, roughness: 0.5 });
    const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
    yAxis.position.set(0, axisLength / 2, 0); // 定位Y轴
    
    // 创建Z轴（蓝色）
    const zAxisGeometry = new THREE.CylinderGeometry(axisWidth, axisWidth, axisLength, 16);
    zAxisGeometry.rotateX(Math.PI / 2); // 旋转使圆柱体沿Z轴方向
    const zAxisMaterial = new THREE.MeshStandardMaterial({ color: 0x0000FF, metalness: 0.5, roughness: 0.5 });
    const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
    zAxis.position.set(0, 0, axisLength / 2); // 定位Z轴
    
    // 创建箭头头部，提升可视性和方向感
    const coneHeight = 0.5; // 箭头高度
    const coneRadius = 0.2; // 箭头半径
    
    // X轴箭头
    const xConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
    xConeGeometry.rotateZ(-Math.PI / 2); // 旋转使圆锥体沿X轴方向
    const xCone = new THREE.Mesh(xConeGeometry, xAxisMaterial);
    xCone.position.set(axisLength, 0, 0); // 放置在X轴末端
    
    // Y轴箭头
    const yConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
    // Y轴箭头不需要旋转
    const yCone = new THREE.Mesh(yConeGeometry, yAxisMaterial);
    yCone.position.set(0, axisLength, 0); // 放置在Y轴末端
    
    // Z轴箭头
    const zConeGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 16);
    zConeGeometry.rotateX(Math.PI / 2); // 旋转使圆锥体沿Z轴方向
    const zCone = new THREE.Mesh(zConeGeometry, zAxisMaterial);
    zCone.position.set(0, 0, axisLength); // 放置在Z轴末端
    
    // 添加轴标签（X，Y，Z），提高可读性
    // 创建文本标签函数
    function createTextLabel(text, color) {
        // 使用canvas创建纹理，用于标签显示
        const canvas = document.createElement('canvas');
        canvas.width = 64; // 设置画布宽度
        canvas.height = 64; // 设置画布高度
        
        // 获取绘图上下文
        const context = canvas.getContext('2d');
        // 清除画布，设置透明背景
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // 设置文本样式并绘制
        context.font = 'Bold 40px Arial'; // 设置字体
        context.textAlign = 'center'; // 文本居中
        context.textBaseline = 'middle'; // 基线居中
        context.fillStyle = '#' + color.toString(16).padStart(6, '0'); // 设置文本颜色
        context.fillText(text, canvas.width / 2, canvas.height / 2); // 绘制文本
        
        // 创建纹理
        const texture = new THREE.CanvasTexture(canvas);
        
        // 创建精灵材质，用于始终面向相机的标签
        const material = new THREE.SpriteMaterial({ 
            map: texture, // 使用文本纹理
            transparent: true // 启用透明度
        });
        
        // 返回创建的精灵对象
        return new THREE.Sprite(material);
    }
    
    // 创建X轴标签
    const xLabel = createTextLabel('X', 0xFF0000); // 红色X标签
    xLabel.position.set(axisLength + 0.6, 0, 0); // 放置位置
    xLabel.scale.set(1, 1, 1); // 设置大小
    
    // 创建Y轴标签
    const yLabel = createTextLabel('Y', 0x00FF00); // 绿色Y标签
    yLabel.position.set(0, axisLength + 0.6, 0); // 放置位置
    yLabel.scale.set(1, 1, 1); // 设置大小
    
    // 创建Z轴标签
    const zLabel = createTextLabel('Z', 0x0000FF); // 蓝色Z标签
    zLabel.position.set(0, 0, axisLength + 0.6); // 放置位置
    zLabel.scale.set(1, 1, 1); // 设置大小
    
    // 将所有组件添加到坐标轴组
    axesGroup.add(xAxis, yAxis, zAxis, xCone, yCone, zCone, xLabel, yLabel, zLabel);
    
    // 添加坐标轴组到场景
    scene.add(axesGroup);
    
    // 返回坐标轴组，以便后续可能的操作
    return axesGroup;
}

/**
 * 下载CIF文件
 */
function downloadCIFFile() {
    // Get current material ID
    const materialId = getCurrentMaterialId();
    if (!materialId) {
        showErrorMessage('Material ID not found');
        return;
    }
    
    // Get current supercell values if available
    const expansionValues = getExpansionValues();
    const cellType = document.querySelector('input[name="cellType"]:checked')?.value || 'primitive';
    
    // Build URL for download
    let url = `/api/structure/${materialId}/cif`;
    
    // Add supercell parameters if they're not all 1
    if (expansionValues.a > 1 || expansionValues.b > 1 || expansionValues.c > 1) {
        url += `?a=${expansionValues.a}&b=${expansionValues.b}&c=${expansionValues.c}&cellType=${cellType}`;
    }
    
    // Open download in new tab
    window.open(url, '_blank');
}

/**
 * 获取当前材料ID
 * @returns {string|null} 当前材料ID或null
 */
function getCurrentMaterialId() {
    // 从URL中提取ID
    const urlParams = new URLSearchParams(window.location.search);
    const id = urlParams.get('id');
    
    // 如果URL中有ID，直接返回
    if (id) {
        return id;
    }
    
    // 如果没有，尝试从页面元素中获取
    // 假设页面中有一个包含材料ID的元素
    const idElement = document.getElementById('material-id');
    if (idElement && idElement.textContent) {
        return idElement.textContent.trim();
    }
    
    // 如果还是没有找到，返回null
    return null;
}

/**
 * 创建扩胞控制面板
 * @param {HTMLElement} container - 容器元素
 */
function createSupercellPanel(container) {
    // Create main button that expands to show controls
    const mainButton = document.createElement('button');
    mainButton.className = 'supercell-main-button';
    mainButton.textContent = 'Edit Cell';
    mainButton.style.position = 'absolute';
    mainButton.style.bottom = '10px';
    mainButton.style.right = '10px';
    mainButton.style.backgroundColor = '#4CAF50';
    mainButton.style.color = 'white';
    mainButton.style.border = 'none';
    mainButton.style.borderRadius = '4px';
    mainButton.style.padding = '8px 12px';
    mainButton.style.cursor = 'pointer';
    mainButton.style.zIndex = '1000';
    mainButton.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';

    // Create supercell panel container (initially hidden)
    const supercellPanel = document.createElement('div');
    supercellPanel.className = 'supercell-panel';
    supercellPanel.style.position = 'absolute';
    supercellPanel.style.bottom = '50px'; // Position above the button
    supercellPanel.style.right = '10px';
    supercellPanel.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
    supercellPanel.style.borderRadius = '5px';
    supercellPanel.style.padding = '10px';
    supercellPanel.style.display = 'none'; // Initially hidden
    supercellPanel.style.flexDirection = 'column';
    supercellPanel.style.gap = '10px';
    supercellPanel.style.zIndex = '1000';
    supercellPanel.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
    supercellPanel.style.width = '220px';
    
    // Add panel title
    const panelTitle = document.createElement('div');
    panelTitle.className = 'panel-title';
    panelTitle.style.fontWeight = 'bold';
    panelTitle.style.fontSize = '14px';
    panelTitle.style.borderBottom = '1px solid #ddd';
    panelTitle.style.paddingBottom = '5px';
    panelTitle.textContent = 'Cell Controls';
    supercellPanel.appendChild(panelTitle);
    
    // Create expansion controls
    const expansionControls = document.createElement('div');
    expansionControls.style.display = 'flex';
    expansionControls.style.flexDirection = 'column';
    expansionControls.style.gap = '5px';
    
    // Direction labels (a, b, c)
    const directions = ['a', 'b', 'c'];
    const expansionValues = {a: 1, b: 1, c: 1}; // Default values
    
    directions.forEach(dir => {
        const controlRow = document.createElement('div');
        controlRow.style.display = 'flex';
        controlRow.style.alignItems = 'center';
        controlRow.style.gap = '8px';
        
        const label = document.createElement('label');
        label.textContent = `${dir.toUpperCase()} direction:`;
        label.style.width = '80px';
        label.style.fontSize = '12px';
        
        const decreaseBtn = document.createElement('button');
        decreaseBtn.className = 'control-btn';
        decreaseBtn.textContent = '-';
        decreaseBtn.style.width = '25px';
        decreaseBtn.style.height = '25px';
        decreaseBtn.style.backgroundColor = '#f0f0f0';
        decreaseBtn.style.border = '1px solid #ddd';
        decreaseBtn.style.borderRadius = '3px';
        decreaseBtn.style.cursor = 'pointer';
        
        const valueDisplay = document.createElement('span');
        valueDisplay.textContent = expansionValues[dir];
        valueDisplay.style.width = '25px';
        valueDisplay.style.textAlign = 'center';
        valueDisplay.style.fontSize = '14px';
        
        const increaseBtn = document.createElement('button');
        increaseBtn.className = 'control-btn';
        increaseBtn.textContent = '+';
        increaseBtn.style.width = '25px';
        increaseBtn.style.height = '25px';
        increaseBtn.style.backgroundColor = '#f0f0f0';
        increaseBtn.style.border = '1px solid #ddd';
        increaseBtn.style.borderRadius = '3px';
        increaseBtn.style.cursor = 'pointer';
        
        // Add event listeners
        decreaseBtn.addEventListener('click', () => {
            if (expansionValues[dir] > 1) {
                expansionValues[dir]--;
                valueDisplay.textContent = expansionValues[dir];
            }
        });
        
        increaseBtn.addEventListener('click', () => {
            if (expansionValues[dir] < 5) { // Set upper limit to 5 to avoid performance issues
                expansionValues[dir]++;
                valueDisplay.textContent = expansionValues[dir];
            }
        });
        
        controlRow.appendChild(label);
        controlRow.appendChild(decreaseBtn);
        controlRow.appendChild(valueDisplay);
        controlRow.appendChild(increaseBtn);
        
        expansionControls.appendChild(controlRow);
    });
    
    supercellPanel.appendChild(expansionControls);
    
    // Separator
    const separator = document.createElement('div');
    separator.style.height = '1px';
    separator.style.backgroundColor = '#ddd';
    separator.style.margin = '5px 0';
    supercellPanel.appendChild(separator);
    
    // Cell type selection
    const cellTypeControls = document.createElement('div');
    cellTypeControls.style.display = 'flex';
    cellTypeControls.style.flexDirection = 'column';
    cellTypeControls.style.gap = '5px';
    
    const cellTypeLabel = document.createElement('div');
    cellTypeLabel.textContent = 'Cell Type:';
    cellTypeLabel.style.fontSize = '12px';
    cellTypeLabel.style.marginBottom = '5px';
    cellTypeControls.appendChild(cellTypeLabel);
    
    // Create radio button group
    const cellTypes = [
        { id: 'primitive', label: 'Primitive', value: 'primitive' },
        { id: 'conventional', label: 'Conventional', value: 'conventional' }
    ];
    
    const radioGroup = document.createElement('div');
    radioGroup.style.display = 'flex';
    radioGroup.style.gap = '10px';
    
    cellTypes.forEach(type => {
        const radioContainer = document.createElement('div');
        radioContainer.style.display = 'flex';
        radioContainer.style.alignItems = 'center';
        radioContainer.style.gap = '5px';
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'cellType';
        radio.id = type.id;
        radio.value = type.value;
        if (type.value === 'primitive') {
            radio.checked = true; // Default select primitive cell
        }
        
        const radioLabel = document.createElement('label');
        radioLabel.textContent = type.label;
        radioLabel.htmlFor = type.id;
        radioLabel.style.fontSize = '12px';
        
        radioContainer.appendChild(radio);
        radioContainer.appendChild(radioLabel);
        radioGroup.appendChild(radioContainer);
    });
    
    cellTypeControls.appendChild(radioGroup);
    supercellPanel.appendChild(cellTypeControls);
    
    // Apply button
    const applyButton = document.createElement('button');
    applyButton.textContent = 'Apply Changes';
    applyButton.style.marginTop = '10px';
    applyButton.style.padding = '6px 12px';
    applyButton.style.backgroundColor = '#4CAF50';
    applyButton.style.color = 'white';
    applyButton.style.border = 'none';
    applyButton.style.borderRadius = '4px';
    applyButton.style.cursor = 'pointer';
    applyButton.style.width = '100%';
    
    applyButton.addEventListener('mouseover', () => {
        applyButton.style.backgroundColor = '#45a049';
    });
    
    applyButton.addEventListener('mouseout', () => {
        applyButton.style.backgroundColor = '#4CAF50';
    });
    
    applyButton.addEventListener('click', () => {
        const cellType = document.querySelector('input[name="cellType"]:checked').value;
        updateSupercell(expansionValues.a, expansionValues.b, expansionValues.c, cellType);
        // Hide panel after applying changes
        supercellPanel.style.display = 'none';
        mainButton.style.display = 'block';
    });
    
    supercellPanel.appendChild(applyButton);
    
    // Toggle button to show/hide the panel
    mainButton.addEventListener('click', () => {
        supercellPanel.style.display = 'flex';
        mainButton.style.display = 'none';
    });
    
    // Add close button to panel
    const closeButton = document.createElement('button');
    closeButton.textContent = '×';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '5px';
    closeButton.style.right = '5px';
    closeButton.style.backgroundColor = 'transparent';
    closeButton.style.border = 'none';
    closeButton.style.cursor = 'pointer';
    closeButton.style.fontSize = '16px';
    closeButton.style.padding = '0';
    closeButton.style.width = '20px';
    closeButton.style.height = '20px';
    closeButton.style.textAlign = 'center';
    closeButton.style.lineHeight = '20px';
    
    closeButton.addEventListener('click', (e) => {
        e.stopPropagation();
        supercellPanel.style.display = 'none';
        mainButton.style.display = 'block';
    });
    
    supercellPanel.appendChild(closeButton);
    
    // Add to container
    container.appendChild(mainButton);
    container.appendChild(supercellPanel);
}

/**
 * 更新超晶胞
 * @param {number} a - Repetitions in a direction
 * @param {number} b - Repetitions in b direction
 * @param {number} c - Repetitions in c direction
 * @param {string} cellType - Cell type, either 'primitive' or 'conventional'
 */
function updateSupercell(a, b, c, cellType) {
    // Get current material ID
    const materialId = getCurrentMaterialId();
    if (!materialId) {
        showErrorMessage('Material ID not found');
        return;
    }
    
    // Show loading indicator
    showLoadingIndicator();
    
    // Build request URL
    let url = `/api/structure/${materialId}/supercell?a=${a}&b=${b}&c=${c}`;
    
    // Add cell type parameter (if provided)
    if (cellType) {
        url += `&cellType=${cellType}`;
    }
    
    // Send request to get supercell data
    fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Hide loading indicator
            hideLoadingIndicator();
            
            // Render new crystal structure
            renderCrystalStructure(data);
        })
        .catch(error => {
            console.error('Failed to get supercell data:', error);
            hideLoadingIndicator();
            showErrorMessage('Failed to get supercell data. Please try again later.');
        });
}

/**
 * Change cell type
 * @param {string} cellType - Cell type, either 'primitive' or 'conventional'
 */
function changeCellType(cellType) {
    // Get current expansion values from the controls
    const expansionValues = getExpansionValues();
    
    // Reload structure with new cell type
    updateSupercell(expansionValues.a, expansionValues.b, expansionValues.c, cellType);
}

/**
 * Get current expansion values from the controls
 * @returns {Object} Object containing a, b, c values
 */
function getExpansionValues() {
    // This is a new helper function to safely get expansion values
    try {
        // Try to get values from UI elements if they exist
        const aElement = document.querySelector('.supercell-panel div:nth-child(2) div:nth-child(1) span');
        const bElement = document.querySelector('.supercell-panel div:nth-child(2) div:nth-child(2) span');
        const cElement = document.querySelector('.supercell-panel div:nth-child(2) div:nth-child(3) span');
        
        if (aElement && bElement && cElement) {
            return {
                a: parseInt(aElement.textContent, 10) || 1,
                b: parseInt(bElement.textContent, 10) || 1,
                c: parseInt(cElement.textContent, 10) || 1
            };
        }
        
        // Fallback to default values
        return { a: 1, b: 1, c: 1 };
    } catch (error) {
        console.error('Error getting expansion values:', error);
        return { a: 1, b: 1, c: 1 };
    }
}

// 导出公共函数
window.CrystalViewer = {
    init: initCrystalViewer,
    load: loadCrystalStructure,
    rotateLeft: rotateLeft,
    rotateRight: rotateRight,
    resetView: resetView,
    toggleSpin: toggleSpin,
    takeScreenshot: takeScreenshot,
    toggleBackgroundColor: setBackgroundColor,
    downloadCIFFile: downloadCIFFile,
    updateSupercell: updateSupercell,
    changeCellType: changeCellType
};