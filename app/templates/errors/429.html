{% extends "base.html" %}
{% block page_styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/pages/errors.css', v='20250913') }}">
{% endblock %}
{% block title %}{{ _('Too Many Requests') }}{% endblock %}

{% block content %}
<section class="error-hero">
    <div class="container">
        <div class="error-grid">
            <!-- 左侧：状态与说明 -->
            <div class="error-left" role="region" aria-labelledby="err429_title">
                <div class="error-code">429</div>
                <h1 id="err429_title">{{ _('Too Many Requests') }}</h1>
                <p class="error-sub">{{ _('You have sent too many requests in a short time.') }}</p>

                <div class="timer" aria-live="polite">
                    <span>{{ _('Please wait') }}</span>
                    <strong id="retrySeconds">{{ retry_after|default(60) }}</strong>
                    <span>{{ _('seconds') }}</span>
                </div>
            </div>

            <!-- 右侧：验证码与输入框 -->
            <div class="error-right">
                <!-- 简约的人机验证卡片：默认可见，但在倒计时未结束前为禁用态（居中、等距） -->
                <div id="captchaArea" class="captcha-area disabled" aria-hidden="false">
                    <p class="captcha-title">
                        <i class="fas fa-shield-alt"></i>
                        {{ _('Human Verification') }}
                    </p>
                    <p class="captcha-subnote">{{ _('Electrons are in random motion.') }}</p>

                    <!-- 电子动画层（不阻挡交互） -->
                    <canvas id="hvElectrons" class="hv-electrons" aria-hidden="true"></canvas>

                    <!-- 简化：移除文字引导，采用居中直观布局 -->

                    <div class="captcha-row hv-action">
                        <img id="captchaImg429" class="captcha-img" src="{{ url_for('views.captcha429') }}" alt="CAPTCHA" width="220" height="48" />
                        <button id="refreshCaptcha429" class="captcha-btn" type="button" disabled>
                            <i class="fas fa-sync"></i> {{ _('Refresh') }}
                        </button>
                    </div>

                    <div class="captcha-input hv-action">
                        <input id="captchaInput429" type="text" maxlength="5" inputmode="latin" autocomplete="one-time-code"
                               placeholder="{{ _('Enter 5 letters') }}" aria-label="{{ _('Captcha code') }}" disabled />
                        <button id="submitCaptcha429" class="captcha-btn primary" type="button" disabled>
                            <i class="fas fa-check-circle"></i> {{ _('Verify') }}
                        </button>
                    </div>

                    <!-- 常驻提示小框：所有提示文案聚合显示于此 -->
                    <div id="captchaTip" class="captcha-tip info" role="status" aria-live="polite">
                        <i class="tip-icon fas fa-info-circle"></i>
                        <span id="captchaTipText">{{ _('Please wait until the countdown finishes, then enter the captcha to continue') }}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- [Deprecated 20250913] 错误页样式已迁移至 static/css/pages/errors.css（429） -->

<script>
    // 使用后端传入的 retry_after（默认 60）进行倒计时，并在结束后提示进行验证码验证
    const retrySecondsEl = document.getElementById('retrySeconds');
    let seconds = parseInt(retrySecondsEl ? retrySecondsEl.textContent : '60');

    // 验证码相关引用
    const captchaArea = document.getElementById('captchaArea');
    const captchaImg429 = document.getElementById('captchaImg429');
    const refreshCaptcha429 = document.getElementById('refreshCaptcha429');
    const submitCaptcha429 = document.getElementById('submitCaptcha429');
    const captchaInput429 = document.getElementById('captchaInput429');
    const captchaMsg429 = document.getElementById('captchaMsg429');
    const captchaTip = document.getElementById('captchaTip');
    const captchaTipText = document.getElementById('captchaTipText');
    const backUrl = "{{ url_for('views.index') }}";

    let challengePassed = false; // 解释：仅当“时间到且验证码正确”后为 true

    // 电子动画：简单弹性碰撞 + 随机运动
    const electronCanvas = document.getElementById('hvElectrons');
    let electronCtx = null;
    let electrons = [];
    let electronRAF = null;

    function initElectrons() {
        if (!electronCanvas) return;
        electronCtx = electronCanvas.getContext('2d');
        resizeElectrons();
        const N = 10;
        electrons = [];
        for (let i = 0; i < N; i++) {
            const r = 3; // 更小且统一
            // 初速：方向随机，速度在 [V_INIT_MIN, V_INIT_MAX] 内（更高上限）
            const V_INIT_MAX = 3.8, V_INIT_MIN = 1.2;
            const theta = Math.random() * Math.PI * 2;
            const speed = V_INIT_MIN + Math.random() * (V_INIT_MAX - V_INIT_MIN);
            const vx = Math.cos(theta) * speed;
            const vy = Math.sin(theta) * speed;
            const x = r + Math.random() * (electronCanvas.width - 2 * r);
            const y = r + Math.random() * (electronCanvas.height - 2 * r);
            // 跟踪前一帧的速度与角度，以及变化率的指数滑动平均
            electrons.push({ x, y, vx, vy, r, prevSpeed: speed, prevAngle: theta, sAvg: 0, aAvg: 0 });
        }
        animateElectrons();
    }

    // 对速度做小角度随机旋转，并加上轻微噪声，加速/减速保持在范围内
    function steerQuantum(e) {
        // 依据“变化率耦合”调整：速度变化率越小→方向变化率越大；方向变化率越慢→速度变化率越大
        const V_MAX = 4.2, V_MIN = 1.0;
        const BASE_DELTA = 0.28;   // 方向最大旋转基准（约 16°）
        const NOISE_MAX = 0.18;    // 速度噪声上限

        // 当前速度与角度
        const spdNow = Math.hypot(e.vx, e.vy) || V_MIN;
        const angNow = Math.atan2(e.vy, e.vx);

        // 计算变化率并做指数滑动平均，降低瞬时抖动
        const ds = Math.abs(spdNow - (e.prevSpeed || spdNow));
        let dtheta = Math.abs(angNow - (e.prevAngle || angNow));
        // 角度归一化到 [0, π]
        dtheta = Math.min(Math.PI, Math.abs((dtheta + Math.PI) % (2 * Math.PI) - Math.PI));

        const ALPHA = 0.15; // 平滑系数
        e.sAvg = (e.sAvg || 0) * (1 - ALPHA) + ds * ALPHA;
        e.aAvg = (e.aAvg || 0) * (1 - ALPHA) + dtheta * ALPHA;

        // 归一化到 [0,1] 的权重：越小→越接近 1
        const S_RANGE = 0.6; // 速度变化率参考范围
        const A_RANGE = 0.5; // 方向变化率参考范围（弧度）
        const sWeight = Math.max(0, Math.min(1, 1 - e.sAvg / S_RANGE)); // 小速度变化→大权重
        const aWeight = Math.max(0, Math.min(1, 1 - e.aAvg / A_RANGE)); // 小角度变化→大权重

        // 方向旋转角：受 sWeight 控制（速度变化小→方向变化大）
        const delta = BASE_DELTA * Math.max(0.2, sWeight);
        const rot = (Math.random() * 2 - 1) * delta;
        const cosr = Math.cos(rot), sinr = Math.sin(rot);
        let nvx = e.vx * cosr - e.vy * sinr;
        let nvy = e.vx * sinr + e.vy * cosr;

        // 速度噪声：受 aWeight 控制（方向变化小→速度变化大）
        const ax = (Math.random() - 0.5) * (NOISE_MAX * Math.max(0.25, aWeight));
        const ay = (Math.random() - 0.5) * (NOISE_MAX * Math.max(0.25, aWeight));
        nvx += ax; nvy += ay;

        // 速度约束
        const spd = Math.hypot(nvx, nvy) || V_MIN;
        const scale = spd > V_MAX ? V_MAX / spd : (spd < V_MIN ? V_MIN / spd : 1);
        e.vx = nvx * scale;
        e.vy = nvy * scale;

        // 保存当前状态用于下一帧计算变化率
        e.prevSpeed = Math.hypot(e.vx, e.vy) || V_MIN;
        e.prevAngle = Math.atan2(e.vy, e.vx);
    }

    // 边界处理：不做经典弹性，改为随机一个指向内部的新方向与速度
    function bounceQuantum(e) {
        const V_MAX = 4.2, V_MIN = 1.0;
        // 判断靠近哪条边，偏向内侧
        let biasAngle = null;
        const pad = e.r + 1;
        if (e.x - pad <= 0) biasAngle = 0; // 右
        else if (e.x + pad >= electronCanvas.width) biasAngle = Math.PI; // 左
        else if (e.y - pad <= 0) biasAngle = Math.PI / 2; // 下
        else if (e.y + pad >= electronCanvas.height) biasAngle = -Math.PI / 2; // 上
        // 在偏向角附近随机一个角度
        const spread = Math.PI / 3; // ±60° 的扩散
        const theta = (biasAngle !== null ? biasAngle : Math.random() * Math.PI * 2)
                    + (Math.random() - 0.5) * spread;
        const speed = V_MIN + Math.random() * (V_MAX - V_MIN);
        e.vx = Math.cos(theta) * speed;
        e.vy = Math.sin(theta) * speed;
        // 将粒子拉回边内
        e.x = Math.min(Math.max(e.x, pad), electronCanvas.width - pad);
        e.y = Math.min(Math.max(e.y, pad), electronCanvas.height - pad);
    }

    function resizeElectrons() {
        if (!electronCanvas) return;
        const rect = electronCanvas.getBoundingClientRect();
        // 以 CSS 像素为准设置画布尺寸，简化处理
        electronCanvas.width = Math.max(10, Math.floor(rect.width));
        electronCanvas.height = Math.max(10, Math.floor(rect.height));
    }

    function animateElectrons() {
        if (!electronCtx || !electronCanvas) return;
        // 拖尾：用半透明白色覆盖，保留上一帧的轻微残影
        electronCtx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        electronCtx.fillRect(0, 0, electronCanvas.width, electronCanvas.height);
        // 绘制并更新
        for (const e of electrons) {
            // 运动
            e.x += e.vx;
            e.y += e.vy;
            // 边界“量子”处理：靠边时随机内向速度
            if (e.x - e.r < 0 || e.x + e.r > electronCanvas.width || e.y - e.r < 0 || e.y + e.r > electronCanvas.height) {
                bounceQuantum(e);
            }
            // 每帧对速度进行小随机旋转与噪声加减速
            steerQuantum(e);
            // 绘制（蓝色）
            electronCtx.beginPath();
            electronCtx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
            electronCtx.fillStyle = '#3b82f6';
            electronCtx.fill();
        }
        electronRAF = requestAnimationFrame(animateElectrons);
    }

    function stopElectrons() {
        if (electronRAF) cancelAnimationFrame(electronRAF);
        electronRAF = null;
        if (electronCtx && electronCanvas) {
            electronCtx.clearRect(0, 0, electronCanvas.width, electronCanvas.height);
        }
        if (electronCanvas) {
            electronCanvas.style.display = 'none'; // 到时消失
        }
    }

    // 初始化与自适应
    if (electronCanvas) {
        window.addEventListener('resize', () => {
            const wasHidden = electronCanvas.style.display === 'none';
            electronCanvas.style.display = '';
            resizeElectrons();
            if (wasHidden) electronCanvas.style.display = 'none';
        });
        // 监听卡片尺寸变化，实时自适应（防止内容增减导致高度变化）
        const cardEl = document.getElementById('captchaArea');
        if (window.ResizeObserver && cardEl) {
            const ro = new ResizeObserver(() => {
                const wasHidden = electronCanvas.style.display === 'none';
                electronCanvas.style.display = '';
                resizeElectrons();
                if (wasHidden) electronCanvas.style.display = 'none';
            });
            ro.observe(cardEl);
        }
        // 仅在仍需等待的场景启动动画
        if (!isNaN(seconds) && seconds > 0) {
            initElectrons();
        }
    }

    function enableActions() {
        // 解释：现在页面没有可点按钮，保持标志用于阻止重复提交
        challengePassed = true;
    }

    function showCaptchaArea() {
        if (!captchaArea) return;
        captchaArea.classList.remove('is-hidden');
        captchaArea.setAttribute('aria-hidden', 'false');
        // 解释：倒计时结束后请先完成验证码
    }

    function unlockCaptcha() {
        // 移除禁用态样式
        if (captchaArea) {
            captchaArea.classList.remove('disabled');
        }
        // 启用控件
        if (refreshCaptcha429) {
            refreshCaptcha429.disabled = false;
        }
        if (captchaInput429) {
            captchaInput429.disabled = false;
        }
        if (submitCaptcha429) {
            submitCaptcha429.disabled = false;
        }
        // 更新提示
        setTip('info', "{{ _('Please enter the captcha to continue') }}");
    }

    function refreshCaptcha() {
        if (captchaImg429) {
            const base = "{{ url_for('views.captcha429') }}";
            captchaImg429.src = base + '?ts=' + Date.now();
        }
        if (refreshCaptcha429) {
            refreshCaptcha429.classList.add('loading');
            setTimeout(() => refreshCaptcha429.classList.remove('loading'), 550);
        }
    }

    // 进入页面立即刷新一次验证码，确保每次刷新都有新图
    refreshCaptcha();

    function tick() {
        if (isNaN(seconds)) seconds = 60;
        if (seconds > 0) {
            seconds -= 1;
            if (retrySecondsEl) retrySecondsEl.textContent = String(seconds);
            if (seconds === 0) {
                // 提示用户进行验证码验证
                showCaptchaArea();
                refreshCaptcha();
                setTip('info', "{{ _('Time is up. Please complete the captcha to continue') }}");
                unlockCaptcha();
                setTimeout(() => captchaInput429 && captchaInput429.focus(), 50);
                // 停止并隐藏电子动画
                stopElectrons();
            }
        }
    }
    const timer = setInterval(tick, 1000);

    // 无需按钮拦截：页面不提供导航按钮，验证通过后自动跳转

    if (refreshCaptcha429) {
        refreshCaptcha429.addEventListener('click', refreshCaptcha);
    }

    function setTip(type, text) {
        if (!captchaTip) return;
        captchaTip.classList.remove('info','warn','error','success');
        captchaTip.classList.add(type || 'info');
        if (captchaTipText) captchaTipText.textContent = text || '';
    }

    function setLoading(on) {
        if (!submitCaptcha429) return;
        submitCaptcha429.disabled = !!on;
        submitCaptcha429.classList.toggle('loading', !!on);
    }

    async function verifyCaptcha() {
        const code = (captchaInput429 && captchaInput429.value || '').trim();
        if (!code) {
            setTip('warn', "{{ _('Please enter the captcha code') }}");
            // 轻微抖动反馈
            captchaArea && (captchaArea.classList.remove('shake'), captchaArea.offsetHeight, captchaArea.classList.add('shake'));
            return;
        }

        setLoading(true);
        try {
            const resp = await fetch("{{ url_for('views.verify_captcha_429') }}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ captcha: code })
            });
            if (!resp.ok) throw new Error('network');
            const data = await resp.json();
            if (data && data.ok) {
                setTip('success', "{{ _('Verified. Redirecting...') }}");
                enableActions();
                // 成功高亮
                captchaArea && (captchaArea.classList.add('glow'));
                setTimeout(() => window.location.assign(backUrl), 200);
            } else if (data && data.need_wait) {
                // 服务端告知尚需等待
                setTip('info', `${data.seconds} {{ _('seconds remaining, please wait') }}`);
            } else {
                setTip('error', "{{ _('Invalid captcha, please try again') }}");
                refreshCaptcha();
                if (captchaInput429) captchaInput429.focus();
                // 错误抖动
                captchaArea && (captchaArea.classList.remove('shake'), captchaArea.offsetHeight, captchaArea.classList.add('shake'));
            }
        } catch (err) {
            // 网络异常时也提示等待以避免误解
            setTip('warn', "{{ _('Please wait until the countdown finishes, then try again') }}");
        } finally {
            setLoading(false);
        }
    }

    if (submitCaptcha429) {
        submitCaptcha429.addEventListener('click', verifyCaptcha);
    }

    if (captchaInput429) {
        captchaInput429.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                verifyCaptcha();
            }
        });
    }

    // 安全：页面卸载时清理定时器
    window.addEventListener('beforeunload', function () { clearInterval(timer); });
</script>
{% endblock %}
